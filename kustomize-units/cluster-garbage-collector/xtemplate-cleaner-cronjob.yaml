---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: cluster-garbage-collector
  namespace: sylva-system
  labels:
    app: cluster-garbage-collector
spec:
  schedule: "0 */3 * * *" # executed every 3 hours, on the 0th minute of every third hour, on all days of the month, all months, and all days of the week
  concurrencyPolicy: Replace
  successfulJobsHistoryLimit: 5
  failedJobsHistoryLimit: 5
  jobTemplate:
    spec:
      activeDeadlineSeconds: 30
      template:
        metadata:
          labels:
            app: cluster-garbage-collector
        spec:
          serviceAccountName: cluster-garbage-collector-sa
          restartPolicy: Never
          containers:
            - name: xtemplate-cleaner
              image: registry.gitlab.com/sylva-projects/sylva-elements/container-images/kube-job:v1.0.5
              imagePullPolicy: IfNotPresent
              command:
                - '/bin/bash'
                - '-c'
                - |
                  TEMPLATE_TYPES_CR="
                    KubeadmConfigTemplates
                    RKE2ConfigTemplates
                    DockerMachineTemplates
                    VSphereMachineTemplates.*cluster.x-k8s.io
                    OpenStackMachineTemplates
                    Metal3MachineTemplates
                  "
                  for TEMPLATE_TYPE_CR in ${TEMPLATE_TYPES_CR[@]}; do

                    if kubectl api-resources | grep -qi $TEMPLATE_TYPE_CR ; then

                      # Transform the .* used for matching kubectl api-resource, into a plain '.'
                      # (see VSphereMachineTemplates.*cluster.x-k8s.io above)
                      TEMPLATE_TYPE_KIND=${TEMPLATE_TYPE_CR/\*/}

                      # Get all namespaces in which resources are seen (in which Sylva clusters are deployed)
                      for TARGET_NAMESPACE in $(kubectl get $TEMPLATE_TYPE_KIND --all-namespaces | awk '{print $4}' | sort | uniq
); do
                        # Extract resource name from type
                        TEMPLATE_RESOURCE="${TEMPLATE_TYPE_KIND/Template}"

                        # Get all template resources
                        TEMPLATE_RESOURCES=$(kubectl -n "$TARGET_NAMESPACE" get "$TEMPLATE_TYPE_KIND" -o name)

                        # Iterate over template resource names of a specific type
                        for TEMPLATE_RESOURCE_NAME in $TEMPLATE_RESOURCES; do
                            # Check if there are any cloned resources
                            EXISTING_RESOURCES=$(kubectl -n "$TARGET_NAMESPACE" get $TEMPLATE_RESOURCE -l cluster.x-k8s.io/cloned-from-name="$TEMPLATE_RESOURCE_NAME" -o yaml | yq '.items|length')

                            # Delete template resource if no cloned resources exist for a particular 
                            if [[ $EXISTING_RESOURCES -eq 0 ]]; then
                                echo "Deleting $TEMPLATE_TYPE/$TEMPLATE_RESOURCE_NAME"
                                kubectl -n "$TARGET_NAMESPACE" delete "$TEMPLATE_TYPE_KIND/$TEMPLATE_RESOURCE_NAME"
                            fi
                        done
                      done
                    fi
                  done
              securityContext:
                allowPrivilegeEscalation: false
                capabilities:
                  drop:
                    - ALL
                runAsNonRoot: true
                runAsUser: 1000
                privileged: false
                seccompProfile:
                  type: RuntimeDefault
      securityContext:
        runAsNonRoot: true
        seccompProfile:
          type: RuntimeDefault
